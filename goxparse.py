#!/usr/bin/env python

# GOXParse - Glens OpenVas XML Parser

# This script generates simple csv reports by parsing and filtering XML files generated by OpenVAS

# Project URL: https://bitbucket.org/memoryresident/goxparse
# Author URL: https://www.glenscott.net

# The following filters are implemented:
# Filter by IP Address (output single host)
# Filter by max/min CVSS score
# Filter by CVSS 'Threat Level'
# Filter by live/open host/ports in a CSV file (eg output by gnxparse.py)


import sys, argparse
try:
    import  xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

def handle_opts():
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description='Glens OpenVas XML Parser (goxparse)',
		usage='%(prog)s filename.xml [OPTIONS]',
		epilog="""\
usage examples:
	%(prog)s ./scan.xml -ips
	%(prog)s ./scan.xml -host <HOSTIP> 
	%(prog)s ./scan.xml -cvssmin 5 -cvssmax 8 
	%(prog)s ./scan.xml -threatlevel HIGH """
	)

	parser.add_argument('file', action='store',
                   help='File containing OpenVAS XML report')
	parser.add_argument('-i', '-ips', action='store_true', dest='ips',
                   help='Output unfiltered list of scanned ipv4 addresses')
	parser.add_argument('-host', action='store', dest='hostip', nargs='?', default='not_set',
                   help='Host to generate a report for')
	parser.add_argument('-cvssmin', action='store', dest='cvssmin', nargs='?', default='not_set',
                   help='Minimum CVSS level to report'),
	parser.add_argument('-cvssmax', action='store', dest='cvssmax', nargs='?', default='not_set',
                   help='Maximum CVSS level to report'),
	parser.add_argument('-threatlevel', action='store', dest='threat', nargs='?', default='not_set',
                   help='Threat Level to match, LOG/LOW/MEDIUM/HIGH/CRITICAL'),
	parser.add_argument('-matchfile', action='store', dest='matchfile', nargs='?', default='not_set',
                   help='.csv file from which to match open ports, in format HOSTIP,port1,port2,port3'),
	parser.add_argument('-v', '--version', action='version', version='%(prog)s 1.0 (http://bitbucket.org/memoryresident/goxparse )'
	)
	
	args = parser.parse_args()
	
	return args

def nocase_equal(x, y):
	try:
		return x.upper() == y.upper()
	except AttributeError:
		return x == y
	
def parse_ips(openvas_xml_blob):
	host_ip_list = [];
	for report in openvas_xml_blob.findall('./report'):
		for hostentry in report.findall('host'):
			for ipaddress in hostentry.findall('ip'):
				host_ip_list.append(ipaddress.text)
	return host_ip_list 

def chop_port(portstring):
	# cut the portsection into service/port/protocol
	# converts from a string like "ssh (22/tcp)" into list
	# there is a difference in format between newer and older versions
	# of openvas, so the various sighted cases are covered here

	# Store port info in a dict with keys of service, protocol, port
	portinfo={}

	# cases where port looks like "general/icmp"
	if portstring.startswith("general/"):
		portstringlist = portstring.split("/")
		portinfo['service'] = portstringlist[0]
		portinfo['protocol'] = portstringlist[1]
		portinfo['port'] = "N/A"
		
	# cases where port looks like "ntp(123/udp)" 
	elif "(" in portstring:	
		# replace: ")" with "", the middle "(" with a /, then split the whole thing on /
		portstringlist = portstring.replace(")","").replace(" (","/").split("/")
		portinfo['service'] = portstringlist[0]
		portinfo['protocol'] = portstringlist[2]
		portinfo['port'] = portstringlist[1]
		
	# otherwise: port looks like "123/udp"
	else:
		portstringlist = portstring.split("/")
		portinfo['service'] = "" # empty for now so will leave it blank
		portinfo['protocol'] = portstringlist[1]
		portinfo['port'] = portstringlist[0]
	
	return portinfo
		

def read_csv_file(filename):

	try:
		csvfile = open(filename)
		csvlines = csvfile.readlines()
		csvfile.close()
	except: 
		sys.exit("There was a problem opening the .csv file.")
	
	csv_hostport_list = {}
		
	# 1) Read line in csv file (format host,port0,port1,port2,etc)
	# 2) Split line by commas
	# 3) Pop the host entry from the list
	# 4) All remaining entries in line should be ports so append them to currentports list
	# 5) Return a dictionary of hosts => portlists
	
	for hostline in csvlines:
		line = hostline.split(",")
		currenthost = line.pop(0)

		currentports = []
		
		for port in line:
			currentports.append(port.replace("\n","")) # strip newlines from port string
		csv_hostport_list[currenthost] = currentports

	return csv_hostport_list
		
def print_result(host_result, headerflag, csv_hostport_list):

	# Print a single result line to stdout in CSV format
	# Also print the header line if this is the first pass.

	# The csv (output) delimiter
	delimiter = ','
	# These blanks get replaced later.
	csvheader = ""
	csvportmatch = ""
		
	#check if the csv hostport is populated, if so add a column header and start checking for port matches
	if csv_hostport_list:
		csvheader = ('CSVPort Match' + delimiter)
		
		# crosscheck csv with xml results for port matches and set column value appropriately
		for ip_address in csv_hostport_list:
			# act on the ip for this host
			if ip_address == str(host_result['ip']):
				if str(host_result['port']) in csv_hostport_list[ip_address]:
					csvportmatch = ('yes' + delimiter)
					break # exit loop
			else:
				csvportmatch = ('no' + delimiter)
	
	if headerflag == 'true':
		print 'Threat' + delimiter + 'IP' + delimiter + 'CVSS' + delimiter + 'Service' + delimiter + 'Protocol' + delimiter + 'Port' + delimiter + csvheader + 'OID' + delimiter + 'Name'

	print ( 
		str(host_result['threat']) + delimiter + 
		str(host_result['ip']) + delimiter + 
		str(host_result['cvss']) + delimiter + 
		str(host_result['service']) + delimiter + 
		str(host_result['protocol']) + delimiter + 
		str(host_result['port']) + delimiter + 
		str(csvportmatch) + 
		str(host_result['oid']) + delimiter + 
		str(host_result['name'])
		)		
			

def iterate_host_results(openvas_xml_blob, filters, csv_hostport_list):

	# This will be set to false once the first header/host has been printed
	headerflag = 'true'

	# for each result in the report
	for result in openvas_xml_blob.iterfind('./report/results/result'):
		host_result = {}

		# chop port info ahead of time so we only do it once
		portinfo = chop_port(result.find('./port').text)
		
		#set all the info we want into host_result from the current result xml chunk
		host_result['ip'] = str(result.find('./host').text)
		host_result['threat'] = str(result.find('./threat').text)
		host_result['cvss'] = str(result.find('./nvt/cvss_base').text)
		host_result['port'] = portinfo['port']
		host_result['protocol'] = portinfo['protocol']
		host_result['service'] = portinfo['service']
		host_result['name'] = str(result.find('./nvt/name').text)
		host_result['oid'] = str(result.find('./nvt').attrib['oid'])

		# Convert CVSS field to a float to allow some smarter range filtering later
		if (host_result['cvss'] != 'None'):
			try: 
				host_result['cvss'] = float(host_result['cvss'])
			except:
				sys.exit(host_result['cvss'] + 'needs to be a number between 0.0 and 99.0')
			host_result['cvss'] = float(host_result['cvss'])

		
		# Filter successively. Host line must run the gauntlet to be printed.

		if (nocase_equal(filters['threat'],host_result['threat'])) or (filters['threat'] == 'ALL'):
			if (filters['ip'] == host_result['ip']) or (filters['ip'] == 'ALL'):
			
			# if either filter is set 
				if (filters['cvssmin'] != 'not_set') or (filters['cvssmax'] != 'not_set'):
				
					# check both for either/both not set and if so set them to a default
					if (filters['cvssmin'] == 'not_set'):
						filters['cvssmin'] = float('0.0')
		
					if (filters['cvssmax'] == 'not_set'):
						filters['cvssmax'] = float('99.9')
				
					# Check if the value is not 'None'
					if (host_result['cvss'] != 'None'):
						# convert it to a float.
						try:
							host_result['cvss'] = float(host_result['cvss'])
						except: 
							# might want something less nuclear than a sys.exit, like log it somewhere or ignore
							sys.exit("For some reason the CVSS value listed against the host was neither a number or 'none'")
							
						# if the host result is an actual number
						# check the user hasn't given us a bad filter value for cvssmin/cvssmax
						try: 
							cvssmin = float(filters['cvssmin'])
							cvssmax = float(filters['cvssmax'])
						except:
							sys.exit("Please enter min/max CVSS scores between 0 - 10")
							
						cvss = float(host_result['cvss'])

						if (cvssmin <= cvss <= cvssmax):
							print_result(host_result, headerflag, csv_hostport_list)
							headerflag = 'false'
				else:
					print_result(host_result, headerflag, csv_hostport_list)
					headerflag = 'false'
		
def main () :

	args = handle_opts()

	try: 
		openvas_xml_blob = ET.ElementTree(file=args.file)
	except:
		sys.exit("Please specify a valid OpenVAS XML file")

	filters = {'ip' : "ALL", 'cvssmin' : 'not_set', 'cvssmax' : 'not_set', 'threat': "ALL"}

	if args.ips == True:
		print "IPv4 Addresses for scanned hosts:"
		host_ip_list = parse_ips(openvas_xml_blob)
		for ip_address in host_ip_list:
			print (ip_address);
		sys.exit()

	if args.hostip != "not_set":
		filters['ip'] = str(args.hostip)
	if args.cvssmin != "not_set":
		filters['cvssmin'] = args.cvssmin
	if args.cvssmax != "not_set":
		filters['cvssmax'] = args.cvssmax
	if args.threat != "not_set":
		filters['threat'] = args.threat	
	if args.matchfile != "not_set":
		csv_hostport_list = read_csv_file(args.matchfile)
	else:
		csv_hostport_list = ""
				
	iterate_host_results(openvas_xml_blob, filters, csv_hostport_list)
	
if __name__ == "__main__":
   main()